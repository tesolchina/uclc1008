/**
 * Teacher Session Hook
 * 
 * React hook for teachers to create and manage live sessions.
 * Handles session lifecycle, real-time updates, and participant management.
 */

import { useState, useEffect, useCallback } from 'react';
import { supabase } from '@/integrations/supabase/client';
import { useToast } from '@/hooks/use-toast';
import { saveSessionState, loadSessionState, clearSessionState } from '../utils/persistence';
import { DEFAULT_CONFIG } from '../constants';
import type {
  LiveSession,
  SessionParticipant,
  SessionResponse,
  PromptType,
  TeacherSessionState,
  TeacherSessionActions,
} from '../types';

export function useTeacherSession(lessonId: string): TeacherSessionState & TeacherSessionActions {
  const [session, setSession] = useState<LiveSession | null>(null);
  const [participants, setParticipants] = useState<SessionParticipant[]>([]);
  const [responses, setResponses] = useState<SessionResponse[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [isReconnecting, setIsReconnecting] = useState(false);
  const { toast } = useToast();

  // Auto-reconnect to existing session on mount
  useEffect(() => {
    const reconnectSession = async () => {
      const savedState = loadSessionState();
      if (savedState && savedState.lessonId === lessonId && savedState.role === 'teacher') {
        setIsReconnecting(true);
        console.log('[TeacherSession] Attempting to reconnect to session:', savedState.sessionCode);
        
        try {
          const { data, error } = await supabase
            .from('live_sessions')
            .select('*')
            .eq('id', savedState.sessionId)
            .neq('status', 'ended')
            .single();

          if (data && !error) {
            console.log('[TeacherSession] Successfully reconnected to session:', data.session_code);
            setSession({
              ...data,
              current_question_index: data.current_question_index ?? 0,
              allow_ahead: data.allow_ahead ?? true,
              settings: (data.settings as Record<string, unknown>) || {},
            } as LiveSession);
            toast({ title: 'Session restored', description: `Reconnected to ${data.session_code}` });
          } else {
            console.log('[TeacherSession] Session no longer active, clearing saved state');
            clearSessionState();
          }
        } catch (error) {
          console.error('[TeacherSession] Error reconnecting:', error);
          clearSessionState();
        } finally {
          setIsReconnecting(false);
        }
      }
    };

    reconnectSession();
  }, [lessonId, toast]);

  // Create a new session
  const createSession = useCallback(async (title?: string): Promise<LiveSession | null> => {
    setIsLoading(true);
    try {
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) throw new Error('Not authenticated');

      // Determine session_type based on lessonId convention
      // 'lab-space' for generic Lab Space sessions, otherwise use lessonId as type
      const sessionType = lessonId === 'lab-space' ? 'lab-space' : lessonId;
      
      const { data, error } = await supabase
        .from('live_sessions')
        .insert({
          lesson_id: lessonId,
          teacher_id: user.id,
          title: title || `Live Session - Lesson ${lessonId}`,
          session_code: '', // Auto-generated by trigger
          session_type: sessionType, // Critical: enables students to discover sessions
        })
        .select()
        .single();

      if (error) throw error;
      
      const sessionData = {
        ...data,
        current_question_index: data.current_question_index ?? 0,
        allow_ahead: data.allow_ahead ?? true,
        settings: (data.settings as Record<string, unknown>) || {},
      } as LiveSession;
      
      setSession(sessionData);
      
      // Save session state for persistence
      saveSessionState({
        sessionId: data.id,
        sessionCode: data.session_code,
        lessonId: lessonId,
        role: 'teacher',
        joinedAt: new Date().toISOString(),
      });
      
      toast({ title: 'Session created', description: `Code: ${data.session_code}` });
      return sessionData;
    } catch (error) {
      console.error('Error creating session:', error);
      toast({ title: 'Error', description: 'Failed to create session', variant: 'destructive' });
      return null;
    } finally {
      setIsLoading(false);
    }
  }, [lessonId, toast]);

  // Start the session
  const startSession = useCallback(async () => {
    if (!session) return;
    console.log('[TeacherSession] Starting session:', session.id);
    const { error } = await supabase
      .from('live_sessions')
      .update({ 
        status: 'active', 
        started_at: new Date().toISOString(),
        current_section: 'notes',
        current_question_index: 0,
      })
      .eq('id', session.id);
    if (error) console.error('Error starting session:', error);
  }, [session]);

  // Pause/Resume session
  const togglePause = useCallback(async () => {
    if (!session) return;
    const newStatus = session.status === 'paused' ? 'active' : 'paused';
    console.log('[TeacherSession] Toggling pause to:', newStatus);
    const { error } = await supabase
      .from('live_sessions')
      .update({ status: newStatus })
      .eq('id', session.id);
    if (error) console.error('Error toggling pause:', error);
  }, [session]);

  // End the session
  const endSession = useCallback(async () => {
    if (!session) return;
    console.log('[TeacherSession] Ending session:', session.id);
    const { error } = await supabase
      .from('live_sessions')
      .update({ status: 'ended', ended_at: new Date().toISOString() })
      .eq('id', session.id);
    if (error) {
      console.error('Error ending session:', error);
    } else {
      clearSessionState();
      setSession(null);
      setParticipants([]);
      setResponses([]);
    }
  }, [session]);

  // Update current section/question
  const updatePosition = useCallback(async (section: string, questionIndex: number) => {
    if (!session) return;
    console.log('[TeacherSession] Updating position:', { section, questionIndex });
    const { error } = await supabase
      .from('live_sessions')
      .update({ 
        current_section: section, 
        current_question_index: questionIndex 
      })
      .eq('id', session.id);
    if (error) console.error('Error updating position:', error);
  }, [session]);

  // Send a prompt to students
  const sendPrompt = useCallback(async (
    promptType: PromptType, 
    content: string, 
    metadata?: Record<string, unknown>
  ) => {
    if (!session) return;
    const { error } = await supabase
      .from('session_prompts')
      .insert({
        session_id: session.id,
        prompt_type: promptType,
        content,
        metadata: metadata || {},
      } as any);
    if (error) console.error('Error sending prompt:', error);
  }, [session]);

  // Toggle allow_ahead setting
  const toggleAllowAhead = useCallback(async () => {
    if (!session) return;
    console.log('[TeacherSession] Toggling allow_ahead to:', !session.allow_ahead);
    const { error } = await supabase
      .from('live_sessions')
      .update({ allow_ahead: !session.allow_ahead })
      .eq('id', session.id);
    if (error) console.error('Error toggling allow ahead:', error);
  }, [session]);

  // Subscribe to realtime updates
  useEffect(() => {
    if (!session) return;

    console.log('[TeacherSession] Subscribing to session updates for:', session.id);

    const channel = supabase
      .channel(`teacher-session-${session.id}-${Date.now()}`)
      .on('postgres_changes', {
        event: '*',
        schema: 'public',
        table: 'live_sessions',
        filter: `id=eq.${session.id}`,
      }, (payload) => {
        if (payload.eventType === 'UPDATE') {
          console.log('[TeacherSession] Session update:', payload.new);
          const newData = payload.new;
          setSession(prev => prev ? {
            ...prev,
            status: newData.status as LiveSession['status'],
            current_section: newData.current_section,
            current_question_index: newData.current_question_index ?? 0,
            allow_ahead: newData.allow_ahead ?? true,
            settings: (newData.settings as Record<string, unknown>) || {},
            started_at: newData.started_at,
            ended_at: newData.ended_at,
          } : null);
        }
      })
      .on('postgres_changes', {
        event: '*',
        schema: 'public',
        table: 'session_participants',
        filter: `session_id=eq.${session.id}`,
      }, (payload) => {
        console.log('[TeacherSession] Participant update:', payload.eventType);
        if (payload.eventType === 'INSERT') {
          setParticipants(prev => [...prev, payload.new as SessionParticipant]);
        } else if (payload.eventType === 'UPDATE') {
          setParticipants(prev => prev.map(p => p.id === payload.new.id ? payload.new as SessionParticipant : p));
        } else if (payload.eventType === 'DELETE') {
          setParticipants(prev => prev.filter(p => p.id !== payload.old.id));
        }
      })
      .on('postgres_changes', {
        event: '*',
        schema: 'public',
        table: 'session_responses',
        filter: `session_id=eq.${session.id}`,
      }, (payload) => {
        console.log('[TeacherSession] Response update:', payload.eventType);
        if (payload.eventType === 'INSERT') {
          setResponses(prev => [...prev, payload.new as SessionResponse]);
        } else if (payload.eventType === 'UPDATE') {
          setResponses(prev => prev.map(r => r.id === payload.new.id ? payload.new as SessionResponse : r));
        }
      })
      .subscribe((status) => {
        console.log('[TeacherSession] Subscription status:', status);
      });

    // Fetch initial participants and responses
    const fetchData = async () => {
      const [participantsRes, responsesRes] = await Promise.all([
        supabase.from('session_participants').select('*').eq('session_id', session.id),
        supabase.from('session_responses').select('*').eq('session_id', session.id),
      ]);
      if (participantsRes.data) setParticipants(participantsRes.data as SessionParticipant[]);
      if (responsesRes.data) setResponses(responsesRes.data as SessionResponse[]);
    };
    fetchData();

    // Periodic refresh for participants
    const refreshInterval = setInterval(async () => {
      const { data } = await supabase
        .from('session_participants')
        .select('*')
        .eq('session_id', session.id);
      if (data) {
        setParticipants(data as SessionParticipant[]);
      }
    }, DEFAULT_CONFIG.participantRefreshInterval);

    return () => {
      console.log('[TeacherSession] Cleaning up subscription');
      supabase.removeChannel(channel);
      clearInterval(refreshInterval);
    };
  }, [session?.id]);

  // Manual refresh for responses
  const refreshResponses = useCallback(async () => {
    if (!session) return;
    console.log('[TeacherSession] Manually refreshing responses');
    const { data } = await supabase
      .from('session_responses')
      .select('*')
      .eq('session_id', session.id);
    if (data) {
      setResponses(data as SessionResponse[]);
    }
  }, [session]);

  return {
    session,
    participants,
    responses,
    isLoading,
    isReconnecting,
    createSession,
    startSession,
    togglePause,
    endSession,
    updatePosition,
    sendPrompt,
    toggleAllowAhead,
    refreshResponses,
  };
}
