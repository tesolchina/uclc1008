/**
 * Hook for teachers to manage discussion sessions
 */

import { useState, useCallback, useEffect } from 'react';
import { supabase } from '@/integrations/supabase/client';
import { toast } from 'sonner';
import type { DiscussionSession, DiscussionThread } from '../types';
import type { Json } from '@/integrations/supabase/types';

interface SessionResponse {
  id: string;
  participant_id: string;
  response: Json;
  submitted_at: string;
  participant?: {
    display_name: string | null;
    student_identifier: string;
  };
}

interface UseDiscussionSessionOptions {
  weekNumber: number;
  teacherId: string;
}

export function useDiscussionSession({ weekNumber, teacherId }: UseDiscussionSessionOptions) {
  const [session, setSession] = useState<DiscussionSession | null>(null);
  const [liveSessionId, setLiveSessionId] = useState<string | null>(null);
  const [sessionCode, setSessionCode] = useState<string | null>(null);
  const [responses, setResponses] = useState<SessionResponse[]>([]);
  const [threads, setThreads] = useState<DiscussionThread[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [participantCount, setParticipantCount] = useState(0);

  // Create a new discussion session
  const createSession = useCallback(async (taskId?: string): Promise<boolean> => {
    if (!teacherId) {
      toast.error('Not authenticated');
      return false;
    }

    setIsLoading(true);
    try {
      // Create live_session first
      const { data: liveSession, error: liveError } = await supabase
        .from('live_sessions')
        .insert({
          teacher_id: teacherId,
          lesson_id: `week-${weekNumber}-hour-3`,
          status: 'active',
          session_type: 'discussion',
          title: `Week ${weekNumber} Hour 3 Discussion`,
          session_code: '', // Will be auto-generated by trigger
        })
        .select()
        .single();

      if (liveError) throw liveError;

      // Create discussion_session
      const { data: discussionSession, error: discussionError } = await supabase
        .from('discussion_sessions')
        .insert({
          session_id: liveSession.id,
          week_number: weekNumber,
          current_task_id: taskId || null,
        })
        .select()
        .single();

      if (discussionError) throw discussionError;

      setLiveSessionId(liveSession.id);
      setSessionCode(liveSession.session_code);
      setSession(discussionSession);

      toast.success(`Session started! Code: ${liveSession.session_code}`);
      return true;
    } catch (err) {
      console.error('Error creating session:', err);
      toast.error('Failed to create session');
      return false;
    } finally {
      setIsLoading(false);
    }
  }, [weekNumber, teacherId]);

  // Change the current task
  const setCurrentTask = useCallback(async (taskId: string) => {
    if (!session) return;

    try {
      const { error } = await supabase
        .from('discussion_sessions')
        .update({ current_task_id: taskId })
        .eq('id', session.id);

      if (error) throw error;

      setSession(prev => prev ? { ...prev, current_task_id: taskId } : null);

      // Broadcast task change via prompts
      if (liveSessionId) {
        await supabase.from('session_prompts').insert({
          session_id: liveSessionId,
          prompt_type: 'task_change',
          content: taskId,
        });
      }

      toast.success('Task updated');
    } catch (err) {
      console.error('Error updating task:', err);
      toast.error('Failed to update task');
    }
  }, [session, liveSessionId]);

  // End the session
  const endSession = useCallback(async () => {
    if (!liveSessionId) return;

    try {
      const { error } = await supabase
        .from('live_sessions')
        .update({ 
          status: 'ended',
          ended_at: new Date().toISOString(),
        })
        .eq('id', liveSessionId);

      if (error) throw error;

      setSession(null);
      setLiveSessionId(null);
      setSessionCode(null);
      setResponses([]);
      setThreads([]);

      toast.success('Session ended');
    } catch (err) {
      console.error('Error ending session:', err);
      toast.error('Failed to end session');
    }
  }, [liveSessionId]);

  // Send selected responses to AI for commentary
  const generateAiCommentary = useCallback(async (responseIds: string[]): Promise<string | null> => {
    if (responseIds.length === 0) {
      toast.error('Select at least one response');
      return null;
    }

    const selectedResponses = responses.filter(r => responseIds.includes(r.id));
    
    try {
      const { data, error } = await supabase.functions.invoke('chat', {
        body: {
          messages: [
            {
              role: 'system',
              content: `You are an academic writing instructor providing commentary on student responses in a live classroom discussion. 
              
Your task:
1. Identify common patterns (strengths and areas for improvement)
2. Highlight one or two exemplary elements from the responses
3. Provide a teaching point that benefits the whole class
4. Keep it concise (150-200 words) and constructive

Format your response for classroom display - use simple formatting, be encouraging, and focus on learning.`
            },
            {
              role: 'user',
              content: `Here are the student responses to review:\n\n${selectedResponses.map((r, i) => 
                `Response ${i + 1} (${r.participant?.display_name || 'Student'}):\n${JSON.stringify(r.response)}`
              ).join('\n\n')}`
            }
          ],
          studentId: teacherId,
        }
      });

      if (error) throw error;

      const commentary = data?.content || data?.message || null;

      // Save AI commentary as a thread
      if (commentary && liveSessionId && selectedResponses.length > 0) {
        await supabase.from('discussion_threads').insert({
          session_id: liveSessionId,
          response_id: selectedResponses[0].id,
          author_type: 'ai',
          content: commentary,
        });
      }

      return commentary;
    } catch (err) {
      console.error('Error generating AI commentary:', err);
      toast.error('Failed to generate AI commentary');
      return null;
    }
  }, [responses, liveSessionId, teacherId]);

  // Add teacher comment
  const addTeacherComment = useCallback(async (content: string, parentId?: string): Promise<boolean> => {
    if (!liveSessionId) return false;

    try {
      const { error } = await supabase.from('discussion_threads').insert({
        session_id: liveSessionId,
        author_type: 'teacher',
        content,
        parent_id: parentId || null,
      });

      if (error) throw error;
      return true;
    } catch (err) {
      console.error('Error adding comment:', err);
      toast.error('Failed to add comment');
      return false;
    }
  }, [liveSessionId]);

  // Toggle spotlight on a thread
  const toggleSpotlight = useCallback(async (threadId: string, isSpotlight: boolean) => {
    try {
      const { error } = await supabase
        .from('discussion_threads')
        .update({ is_spotlight: isSpotlight })
        .eq('id', threadId);

      if (error) throw error;

      setThreads(prev => prev.map(t => 
        t.id === threadId ? { ...t, is_spotlight: isSpotlight } : t
      ));

      toast.success(isSpotlight ? 'Shared with class' : 'Removed from spotlight');
    } catch (err) {
      console.error('Error toggling spotlight:', err);
    }
  }, []);

  // Subscribe to real-time updates
  useEffect(() => {
    if (!liveSessionId) return;

    const channel = supabase
      .channel(`discussion-${liveSessionId}`)
      .on(
        'postgres_changes',
        {
          event: '*',
          schema: 'public',
          table: 'session_responses',
          filter: `session_id=eq.${liveSessionId}`,
        },
        async () => {
          // Refetch responses
          const { data } = await supabase
            .from('session_responses')
            .select(`
              id,
              participant_id,
              response,
              submitted_at,
              session_participants!session_responses_participant_id_fkey(
                display_name,
                student_identifier
              )
            `)
            .eq('session_id', liveSessionId)
            .order('submitted_at', { ascending: false });

          if (data) {
            setResponses(data.map(r => ({
              id: r.id,
              participant_id: r.participant_id,
              response: r.response,
              submitted_at: r.submitted_at,
              participant: r.session_participants as SessionResponse['participant'],
            })));
          }
        }
      )
      .on(
        'postgres_changes',
        {
          event: '*',
          schema: 'public',
          table: 'discussion_threads',
          filter: `session_id=eq.${liveSessionId}`,
        },
        async () => {
          const { data } = await supabase
            .from('discussion_threads')
            .select('*')
            .eq('session_id', liveSessionId)
            .order('created_at', { ascending: true });

          if (data) {
            setThreads(data.map(t => ({
              ...t,
              author_type: t.author_type as 'ai' | 'teacher',
            })));
          }
        }
      )
      .on(
        'postgres_changes',
        {
          event: '*',
          schema: 'public',
          table: 'session_participants',
          filter: `session_id=eq.${liveSessionId}`,
        },
        async () => {
          const { count } = await supabase
            .from('session_participants')
            .select('*', { count: 'exact', head: true })
            .eq('session_id', liveSessionId)
            .eq('is_online', true);

          setParticipantCount(count || 0);
        }
      )
      .subscribe();

    // Initial fetch
    const fetchInitialData = async () => {
      const [responsesRes, threadsRes, countRes] = await Promise.all([
        supabase
          .from('session_responses')
          .select(`
            id,
            participant_id,
            response,
            submitted_at,
            session_participants!session_responses_participant_id_fkey(
              display_name,
              student_identifier
            )
          `)
          .eq('session_id', liveSessionId)
          .order('submitted_at', { ascending: false }),
        supabase
          .from('discussion_threads')
          .select('*')
          .eq('session_id', liveSessionId)
          .order('created_at', { ascending: true }),
        supabase
          .from('session_participants')
          .select('*', { count: 'exact', head: true })
          .eq('session_id', liveSessionId)
          .eq('is_online', true),
      ]);

      if (responsesRes.data) {
        setResponses(responsesRes.data.map(r => ({
          id: r.id,
          participant_id: r.participant_id,
          response: r.response,
          submitted_at: r.submitted_at,
          participant: r.session_participants as SessionResponse['participant'],
        })));
      }
      if (threadsRes.data) {
        setThreads(threadsRes.data.map(t => ({
          ...t,
          author_type: t.author_type as 'ai' | 'teacher',
        })));
      }
      setParticipantCount(countRes.count || 0);
    };

    fetchInitialData();

    return () => {
      supabase.removeChannel(channel);
    };
  }, [liveSessionId]);

  return {
    session,
    sessionCode,
    responses,
    threads,
    isLoading,
    participantCount,
    createSession,
    setCurrentTask,
    endSession,
    generateAiCommentary,
    addTeacherComment,
    toggleSpotlight,
  };
}
