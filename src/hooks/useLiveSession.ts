import { useState, useEffect, useCallback } from 'react';
import { supabase } from '@/integrations/supabase/client';
import { useToast } from '@/hooks/use-toast';

export interface LiveSession {
  id: string;
  session_code: string;
  lesson_id: string;
  teacher_id: string;
  title: string | null;
  status: 'waiting' | 'active' | 'paused' | 'ended';
  current_section: string | null;
  current_question_index: number;
  allow_ahead: boolean;
  settings: Record<string, unknown>;
  started_at: string | null;
  ended_at: string | null;
  created_at: string;
}

export interface SessionParticipant {
  id: string;
  session_id: string;
  student_identifier: string;
  display_name: string | null;
  is_online: boolean;
  last_seen_at: string;
  current_section: string | null;
  joined_at: string;
}

export interface SessionResponse {
  id: string;
  session_id: string;
  participant_id: string;
  question_type: string;
  question_index: number;
  response: Record<string, unknown>;
  is_correct: boolean | null;
  ai_feedback: string | null;
  submitted_at: string;
}

export interface SessionPrompt {
  id: string;
  session_id: string;
  prompt_type: 'message' | 'focus' | 'timer' | 'poll';
  content: string;
  metadata: Record<string, unknown>;
  created_at: string;
}

// Hook for teachers to manage live sessions
export function useTeacherSession(lessonId: string) {
  const [session, setSession] = useState<LiveSession | null>(null);
  const [participants, setParticipants] = useState<SessionParticipant[]>([]);
  const [responses, setResponses] = useState<SessionResponse[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const { toast } = useToast();

  // Create a new session
  const createSession = useCallback(async (title?: string) => {
    setIsLoading(true);
    try {
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) throw new Error('Not authenticated');

      const { data, error } = await supabase
        .from('live_sessions')
        .insert({
          lesson_id: lessonId,
          teacher_id: user.id,
          title: title || `Live Session - Lesson ${lessonId}`,
          session_code: '', // Will be auto-generated by trigger
        })
        .select()
        .single();

      if (error) throw error;
      setSession(data as LiveSession);
      toast({ title: 'Session created', description: `Code: ${data.session_code}` });
      return data as LiveSession;
    } catch (error) {
      console.error('Error creating session:', error);
      toast({ title: 'Error', description: 'Failed to create session', variant: 'destructive' });
      return null;
    } finally {
      setIsLoading(false);
    }
  }, [lessonId, toast]);

  // Start the session
  const startSession = useCallback(async () => {
    if (!session) return;
    const { error } = await supabase
      .from('live_sessions')
      .update({ status: 'active', started_at: new Date().toISOString() })
      .eq('id', session.id);
    if (error) console.error('Error starting session:', error);
  }, [session]);

  // Pause/Resume session
  const togglePause = useCallback(async () => {
    if (!session) return;
    const newStatus = session.status === 'paused' ? 'active' : 'paused';
    const { error } = await supabase
      .from('live_sessions')
      .update({ status: newStatus })
      .eq('id', session.id);
    if (error) console.error('Error toggling pause:', error);
  }, [session]);

  // End the session
  const endSession = useCallback(async () => {
    if (!session) return;
    const { error } = await supabase
      .from('live_sessions')
      .update({ status: 'ended', ended_at: new Date().toISOString() })
      .eq('id', session.id);
    if (error) console.error('Error ending session:', error);
  }, [session]);

  // Update current section/question
  const updatePosition = useCallback(async (section: string, questionIndex: number) => {
    if (!session) return;
    const { error } = await supabase
      .from('live_sessions')
      .update({ current_section: section, current_question_index: questionIndex })
      .eq('id', session.id);
    if (error) console.error('Error updating position:', error);
  }, [session]);

  // Send a prompt to students
  const sendPrompt = useCallback(async (promptType: SessionPrompt['prompt_type'], content: string, metadata?: Record<string, unknown>) => {
    if (!session) return;
    const { error } = await supabase
      .from('session_prompts')
      .insert({
        session_id: session.id,
        prompt_type: promptType,
        content,
        metadata: metadata || {},
      } as any);
    if (error) console.error('Error sending prompt:', error);
  }, [session]);

  // Toggle allow_ahead setting
  const toggleAllowAhead = useCallback(async () => {
    if (!session) return;
    const { error } = await supabase
      .from('live_sessions')
      .update({ allow_ahead: !session.allow_ahead })
      .eq('id', session.id);
    if (error) console.error('Error toggling allow ahead:', error);
  }, [session]);

  // Subscribe to realtime updates
  useEffect(() => {
    if (!session) return;

    const channel = supabase
      .channel(`teacher-session-${session.id}`)
      .on('postgres_changes', {
        event: '*',
        schema: 'public',
        table: 'live_sessions',
        filter: `id=eq.${session.id}`,
      }, (payload) => {
        if (payload.eventType === 'UPDATE') {
          setSession(payload.new as LiveSession);
        }
      })
      .on('postgres_changes', {
        event: '*',
        schema: 'public',
        table: 'session_participants',
        filter: `session_id=eq.${session.id}`,
      }, (payload) => {
        if (payload.eventType === 'INSERT') {
          setParticipants(prev => [...prev, payload.new as SessionParticipant]);
        } else if (payload.eventType === 'UPDATE') {
          setParticipants(prev => prev.map(p => p.id === payload.new.id ? payload.new as SessionParticipant : p));
        } else if (payload.eventType === 'DELETE') {
          setParticipants(prev => prev.filter(p => p.id !== payload.old.id));
        }
      })
      .on('postgres_changes', {
        event: 'INSERT',
        schema: 'public',
        table: 'session_responses',
        filter: `session_id=eq.${session.id}`,
      }, (payload) => {
        setResponses(prev => [...prev, payload.new as SessionResponse]);
      })
      .subscribe();

    // Fetch initial participants and responses
    const fetchData = async () => {
      const [participantsRes, responsesRes] = await Promise.all([
        supabase.from('session_participants').select('*').eq('session_id', session.id),
        supabase.from('session_responses').select('*').eq('session_id', session.id),
      ]);
      if (participantsRes.data) setParticipants(participantsRes.data as SessionParticipant[]);
      if (responsesRes.data) setResponses(responsesRes.data as SessionResponse[]);
    };
    fetchData();

    return () => {
      supabase.removeChannel(channel);
    };
  }, [session?.id]);

  return {
    session,
    participants,
    responses,
    isLoading,
    createSession,
    startSession,
    togglePause,
    endSession,
    updatePosition,
    sendPrompt,
    toggleAllowAhead,
  };
}

// Hook for students to join and participate in sessions
export function useStudentSession(studentIdentifier: string) {
  const [session, setSession] = useState<LiveSession | null>(null);
  const [participant, setParticipant] = useState<SessionParticipant | null>(null);
  const [prompts, setPrompts] = useState<SessionPrompt[]>([]);
  const [latestPrompt, setLatestPrompt] = useState<SessionPrompt | null>(null);
  const [responses, setResponses] = useState<SessionResponse[]>([]);
  const [isJoining, setIsJoining] = useState(false);
  const { toast } = useToast();

  // Join a session by code
  const joinSession = useCallback(async (sessionCode: string, displayName?: string) => {
    setIsJoining(true);
    try {
      // Find the session
      const { data: sessionData, error: sessionError } = await supabase
        .from('live_sessions')
        .select('*')
        .eq('session_code', sessionCode.toUpperCase())
        .neq('status', 'ended')
        .single();

      if (sessionError || !sessionData) {
        toast({ title: 'Session not found', description: 'Check the code and try again', variant: 'destructive' });
        return false;
      }

      // Join as participant (upsert to handle rejoins)
      const { data: participantData, error: participantError } = await supabase
        .from('session_participants')
        .upsert({
          session_id: sessionData.id,
          student_identifier: studentIdentifier,
          display_name: displayName || null,
          is_online: true,
          last_seen_at: new Date().toISOString(),
        }, { onConflict: 'session_id,student_identifier' })
        .select()
        .single();

      if (participantError) throw participantError;

      setSession(sessionData as LiveSession);
      setParticipant(participantData as SessionParticipant);
      toast({ title: 'Joined session!', description: sessionData.title || `Session ${sessionCode}` });
      return true;
    } catch (error) {
      console.error('Error joining session:', error);
      toast({ title: 'Error', description: 'Failed to join session', variant: 'destructive' });
      return false;
    } finally {
      setIsJoining(false);
    }
  }, [studentIdentifier, toast]);

  // Leave the session
  const leaveSession = useCallback(async () => {
    if (!participant) return;
    await supabase
      .from('session_participants')
      .update({ is_online: false })
      .eq('id', participant.id);
    setSession(null);
    setParticipant(null);
    setPrompts([]);
    setLatestPrompt(null);
  }, [participant]);

  // Submit a response
  const submitResponse = useCallback(async (
    questionType: string,
    questionIndex: number,
    response: Record<string, unknown>,
    isCorrect?: boolean
  ) => {
    if (!session || !participant) return;
    const { error } = await supabase
      .from('session_responses')
      .upsert({
        session_id: session.id,
        participant_id: participant.id,
        question_type: questionType,
        question_index: questionIndex,
        response,
        is_correct: isCorrect ?? null,
      } as any, { onConflict: 'session_id,participant_id,question_type,question_index' });
    if (error) console.error('Error submitting response:', error);
  }, [session, participant]);

  // Update current section (heartbeat)
  const updateSection = useCallback(async (section: string) => {
    if (!participant) return;
    await supabase
      .from('session_participants')
      .update({ 
        current_section: section, 
        last_seen_at: new Date().toISOString(),
        is_online: true 
      })
      .eq('id', participant.id);
  }, [participant]);

  // Subscribe to realtime updates
  useEffect(() => {
    if (!session) return;

    const channel = supabase
      .channel(`student-session-${session.id}`)
      .on('postgres_changes', {
        event: 'UPDATE',
        schema: 'public',
        table: 'live_sessions',
        filter: `id=eq.${session.id}`,
      }, (payload) => {
        setSession(payload.new as LiveSession);
      })
      .on('postgres_changes', {
        event: 'INSERT',
        schema: 'public',
        table: 'session_prompts',
        filter: `session_id=eq.${session.id}`,
      }, (payload) => {
        const newPrompt = payload.new as SessionPrompt;
        setPrompts(prev => [...prev, newPrompt]);
        setLatestPrompt(newPrompt);
      })
      .subscribe();

    // Heartbeat to keep online status
    const heartbeat = setInterval(() => {
      if (participant) {
        supabase
          .from('session_participants')
          .update({ last_seen_at: new Date().toISOString(), is_online: true })
          .eq('id', participant.id);
      }
    }, 30000);

    return () => {
      supabase.removeChannel(channel);
      clearInterval(heartbeat);
    };
  }, [session?.id, participant?.id]);

  // Clear latest prompt after viewing
  const dismissPrompt = useCallback(() => {
    setLatestPrompt(null);
  }, []);

  return {
    session,
    participant,
    prompts,
    latestPrompt,
    responses,
    isJoining,
    joinSession,
    leaveSession,
    submitResponse,
    updateSection,
    dismissPrompt,
  };
}
