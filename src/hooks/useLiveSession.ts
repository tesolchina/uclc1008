import { useState, useEffect, useCallback } from 'react';
import { supabase } from '@/integrations/supabase/client';
import { useToast } from '@/hooks/use-toast';

export interface LiveSession {
  id: string;
  session_code: string;
  lesson_id: string;
  teacher_id: string;
  title: string | null;
  status: 'waiting' | 'active' | 'paused' | 'ended';
  current_section: string | null;
  current_question_index: number;
  allow_ahead: boolean;
  settings: Record<string, unknown>;
  started_at: string | null;
  ended_at: string | null;
  created_at: string;
}

export interface SessionParticipant {
  id: string;
  session_id: string;
  student_identifier: string;
  display_name: string | null;
  is_online: boolean;
  last_seen_at: string;
  current_section: string | null;
  joined_at: string;
}

export interface SessionResponse {
  id: string;
  session_id: string;
  participant_id: string;
  question_type: string;
  question_index: number;
  response: Record<string, unknown>;
  is_correct: boolean | null;
  ai_feedback: string | null;
  submitted_at: string;
}

export interface SessionPrompt {
  id: string;
  session_id: string;
  prompt_type: 'message' | 'focus' | 'timer' | 'poll';
  content: string;
  metadata: Record<string, unknown>;
  created_at: string;
}

// Hook for teachers to manage live sessions
export function useTeacherSession(lessonId: string) {
  const [session, setSession] = useState<LiveSession | null>(null);
  const [participants, setParticipants] = useState<SessionParticipant[]>([]);
  const [responses, setResponses] = useState<SessionResponse[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const { toast } = useToast();

  // Create a new session
  const createSession = useCallback(async (title?: string) => {
    setIsLoading(true);
    try {
      const { data: { user } } = await supabase.auth.getUser();
      if (!user) throw new Error('Not authenticated');

      const { data, error } = await supabase
        .from('live_sessions')
        .insert({
          lesson_id: lessonId,
          teacher_id: user.id,
          title: title || `Live Session - Lesson ${lessonId}`,
          session_code: '', // Will be auto-generated by trigger
        })
        .select()
        .single();

      if (error) throw error;
      setSession(data as LiveSession);
      toast({ title: 'Session created', description: `Code: ${data.session_code}` });
      return data as LiveSession;
    } catch (error) {
      console.error('Error creating session:', error);
      toast({ title: 'Error', description: 'Failed to create session', variant: 'destructive' });
      return null;
    } finally {
      setIsLoading(false);
    }
  }, [lessonId, toast]);

  // Start the session
  const startSession = useCallback(async () => {
    if (!session) return;
    console.log('[TeacherSession] Starting session:', session.id);
    const { error } = await supabase
      .from('live_sessions')
      .update({ 
        status: 'active', 
        started_at: new Date().toISOString(),
        current_section: 'notes',
        current_question_index: 0,
      })
      .eq('id', session.id);
    if (error) console.error('Error starting session:', error);
  }, [session]);

  // Pause/Resume session
  const togglePause = useCallback(async () => {
    if (!session) return;
    const newStatus = session.status === 'paused' ? 'active' : 'paused';
    console.log('[TeacherSession] Toggling pause to:', newStatus);
    const { error } = await supabase
      .from('live_sessions')
      .update({ status: newStatus })
      .eq('id', session.id);
    if (error) console.error('Error toggling pause:', error);
  }, [session]);

  // End the session
  const endSession = useCallback(async () => {
    if (!session) return;
    console.log('[TeacherSession] Ending session:', session.id);
    const { error } = await supabase
      .from('live_sessions')
      .update({ status: 'ended', ended_at: new Date().toISOString() })
      .eq('id', session.id);
    if (error) console.error('Error ending session:', error);
  }, [session]);

  // Update current section/question - CRITICAL for sync
  const updatePosition = useCallback(async (section: string, questionIndex: number) => {
    if (!session) return;
    console.log('[TeacherSession] Updating position:', { section, questionIndex });
    const { error } = await supabase
      .from('live_sessions')
      .update({ 
        current_section: section, 
        current_question_index: questionIndex 
      })
      .eq('id', session.id);
    if (error) console.error('Error updating position:', error);
  }, [session]);

  // Send a prompt to students
  const sendPrompt = useCallback(async (promptType: SessionPrompt['prompt_type'], content: string, metadata?: Record<string, unknown>) => {
    if (!session) return;
    const { error } = await supabase
      .from('session_prompts')
      .insert({
        session_id: session.id,
        prompt_type: promptType,
        content,
        metadata: metadata || {},
      } as any);
    if (error) console.error('Error sending prompt:', error);
  }, [session]);

  // Toggle allow_ahead setting
  const toggleAllowAhead = useCallback(async () => {
    if (!session) return;
    console.log('[TeacherSession] Toggling allow_ahead to:', !session.allow_ahead);
    const { error } = await supabase
      .from('live_sessions')
      .update({ allow_ahead: !session.allow_ahead })
      .eq('id', session.id);
    if (error) console.error('Error toggling allow ahead:', error);
  }, [session]);

  // Subscribe to realtime updates
  useEffect(() => {
    if (!session) return;

    console.log('[TeacherSession] Subscribing to session updates for:', session.id);

    const channel = supabase
      .channel(`teacher-session-${session.id}-${Date.now()}`)
      .on('postgres_changes', {
        event: '*',
        schema: 'public',
        table: 'live_sessions',
        filter: `id=eq.${session.id}`,
      }, (payload) => {
        if (payload.eventType === 'UPDATE') {
          console.log('[TeacherSession] Session update:', payload.new);
          const newData = payload.new;
          setSession(prev => prev ? {
            ...prev,
            status: newData.status as LiveSession['status'],
            current_section: newData.current_section,
            current_question_index: newData.current_question_index ?? 0,
            allow_ahead: newData.allow_ahead ?? true,
            settings: (newData.settings as Record<string, unknown>) || {},
            started_at: newData.started_at,
            ended_at: newData.ended_at,
          } : null);
        }
      })
      .on('postgres_changes', {
        event: '*',
        schema: 'public',
        table: 'session_participants',
        filter: `session_id=eq.${session.id}`,
      }, (payload) => {
        console.log('[TeacherSession] Participant update:', payload.eventType);
        if (payload.eventType === 'INSERT') {
          setParticipants(prev => [...prev, payload.new as SessionParticipant]);
        } else if (payload.eventType === 'UPDATE') {
          setParticipants(prev => prev.map(p => p.id === payload.new.id ? payload.new as SessionParticipant : p));
        } else if (payload.eventType === 'DELETE') {
          setParticipants(prev => prev.filter(p => p.id !== payload.old.id));
        }
      })
      .on('postgres_changes', {
        event: '*',
        schema: 'public',
        table: 'session_responses',
        filter: `session_id=eq.${session.id}`,
      }, (payload) => {
        console.log('[TeacherSession] Response update:', payload.eventType);
        if (payload.eventType === 'INSERT') {
          setResponses(prev => [...prev, payload.new as SessionResponse]);
        } else if (payload.eventType === 'UPDATE') {
          setResponses(prev => prev.map(r => r.id === payload.new.id ? payload.new as SessionResponse : r));
        }
      })
      .subscribe((status) => {
        console.log('[TeacherSession] Subscription status:', status);
      });

    // Fetch initial participants and responses
    const fetchData = async () => {
      const [participantsRes, responsesRes] = await Promise.all([
        supabase.from('session_participants').select('*').eq('session_id', session.id),
        supabase.from('session_responses').select('*').eq('session_id', session.id),
      ]);
      if (participantsRes.data) setParticipants(participantsRes.data as SessionParticipant[]);
      if (responsesRes.data) setResponses(responsesRes.data as SessionResponse[]);
    };
    fetchData();

    // Periodic refresh for participants (to catch stale online status)
    const refreshInterval = setInterval(async () => {
      const { data } = await supabase
        .from('session_participants')
        .select('*')
        .eq('session_id', session.id);
      if (data) {
        setParticipants(data as SessionParticipant[]);
      }
    }, 10000);

    return () => {
      console.log('[TeacherSession] Cleaning up subscription');
      supabase.removeChannel(channel);
      clearInterval(refreshInterval);
    };
  }, [session?.id]);

  return {
    session,
    participants,
    responses,
    isLoading,
    createSession,
    startSession,
    togglePause,
    endSession,
    updatePosition,
    sendPrompt,
    toggleAllowAhead,
  };
}

// Hook for students to join and participate in sessions
export function useStudentSession(studentIdentifier: string) {
  const [session, setSession] = useState<LiveSession | null>(null);
  const [participant, setParticipant] = useState<SessionParticipant | null>(null);
  const [prompts, setPrompts] = useState<SessionPrompt[]>([]);
  const [latestPrompt, setLatestPrompt] = useState<SessionPrompt | null>(null);
  const [responses, setResponses] = useState<SessionResponse[]>([]);
  const [isJoining, setIsJoining] = useState(false);
  const { toast } = useToast();

  // Join a session by code
  const joinSession = useCallback(async (sessionCode: string, displayName?: string) => {
    setIsJoining(true);
    try {
      // Find the session
      const { data: sessionData, error: sessionError } = await supabase
        .from('live_sessions')
        .select('*')
        .eq('session_code', sessionCode.toUpperCase())
        .neq('status', 'ended')
        .single();

      if (sessionError || !sessionData) {
        toast({ title: 'Session not found', description: 'Check the code and try again', variant: 'destructive' });
        return false;
      }

      // Join as participant (upsert to handle rejoins)
      const { data: participantData, error: participantError } = await supabase
        .from('session_participants')
        .upsert({
          session_id: sessionData.id,
          student_identifier: studentIdentifier,
          display_name: displayName || null,
          is_online: true,
          last_seen_at: new Date().toISOString(),
        }, { onConflict: 'session_id,student_identifier' })
        .select()
        .single();

      if (participantError) throw participantError;

      // Fetch existing responses for this participant
      const { data: existingResponses } = await supabase
        .from('session_responses')
        .select('*')
        .eq('session_id', sessionData.id)
        .eq('participant_id', participantData.id);
      
      if (existingResponses) {
        setResponses(existingResponses as SessionResponse[]);
      }

      setSession({
        ...sessionData,
        current_question_index: sessionData.current_question_index ?? 0,
        allow_ahead: sessionData.allow_ahead ?? true,
        settings: (sessionData.settings as Record<string, unknown>) || {},
      } as LiveSession);
      setParticipant(participantData as SessionParticipant);
      toast({ title: 'Joined session!', description: sessionData.title || `Session ${sessionCode}` });
      return true;
    } catch (error) {
      console.error('Error joining session:', error);
      toast({ title: 'Error', description: 'Failed to join session', variant: 'destructive' });
      return false;
    } finally {
      setIsJoining(false);
    }
  }, [studentIdentifier, toast]);

  // Leave the session
  const leaveSession = useCallback(async () => {
    if (!participant) return;
    await supabase
      .from('session_participants')
      .update({ is_online: false })
      .eq('id', participant.id);
    setSession(null);
    setParticipant(null);
    setPrompts([]);
    setLatestPrompt(null);
    setResponses([]);
  }, [participant]);

  // Submit a response
  const submitResponse = useCallback(async (
    questionType: string,
    questionIndex: number,
    response: Record<string, unknown>,
    isCorrect?: boolean
  ) => {
    if (!session || !participant) return;
    
    const { data, error } = await supabase
      .from('session_responses')
      .upsert({
        session_id: session.id,
        participant_id: participant.id,
        question_type: questionType,
        question_index: questionIndex,
        response,
        is_correct: isCorrect ?? null,
      } as any, { onConflict: 'session_id,participant_id,question_type,question_index' })
      .select()
      .single();
    
    if (error) {
      console.error('Error submitting response:', error);
    } else if (data) {
      // Update local responses state
      setResponses(prev => {
        const existing = prev.findIndex(r => 
          r.question_type === questionType && r.question_index === questionIndex
        );
        if (existing >= 0) {
          const updated = [...prev];
          updated[existing] = data as SessionResponse;
          return updated;
        }
        return [...prev, data as SessionResponse];
      });
    }
  }, [session, participant]);

  // Update current section (heartbeat)
  const updateSection = useCallback(async (section: string) => {
    if (!participant) return;
    await supabase
      .from('session_participants')
      .update({ 
        current_section: section, 
        last_seen_at: new Date().toISOString(),
        is_online: true 
      })
      .eq('id', participant.id);
  }, [participant]);

  // Subscribe to realtime updates - CRITICAL for sync
  useEffect(() => {
    if (!session) return;

    console.log('[StudentSession] Subscribing to session updates for:', session.id);

    const channel = supabase
      .channel(`student-session-${session.id}-${Date.now()}`)
      // Listen for session updates (teacher position changes, pause/resume, etc.)
      .on('postgres_changes', {
        event: 'UPDATE',
        schema: 'public',
        table: 'live_sessions',
        filter: `id=eq.${session.id}`,
      }, (payload) => {
        console.log('[StudentSession] Session update received:', payload.new);
        const newSession = payload.new;
        setSession(prev => prev ? {
          ...prev,
          status: newSession.status as LiveSession['status'],
          current_section: newSession.current_section,
          current_question_index: newSession.current_question_index ?? 0,
          allow_ahead: newSession.allow_ahead ?? true,
          settings: (newSession.settings as Record<string, unknown>) || {},
          ended_at: newSession.ended_at,
        } : null);
      })
      // Listen for new prompts from teacher
      .on('postgres_changes', {
        event: 'INSERT',
        schema: 'public',
        table: 'session_prompts',
        filter: `session_id=eq.${session.id}`,
      }, (payload) => {
        console.log('[StudentSession] New prompt received:', payload.new);
        const newPrompt = payload.new as SessionPrompt;
        setPrompts(prev => [...prev, newPrompt]);
        setLatestPrompt(newPrompt);
      })
      .subscribe((status) => {
        console.log('[StudentSession] Subscription status:', status);
      });

    // Heartbeat to keep online status and re-fetch session state
    const heartbeat = setInterval(async () => {
      if (participant) {
        // Update participant last_seen
        await supabase
          .from('session_participants')
          .update({ last_seen_at: new Date().toISOString(), is_online: true })
          .eq('id', participant.id);
        
        // Also re-fetch session to ensure sync (backup for missed realtime events)
        const { data: freshSession } = await supabase
          .from('live_sessions')
          .select('*')
          .eq('id', session.id)
          .single();
        
        if (freshSession) {
          setSession(prev => prev ? {
            ...prev,
            status: freshSession.status as LiveSession['status'],
            current_section: freshSession.current_section,
            current_question_index: freshSession.current_question_index ?? 0,
            allow_ahead: freshSession.allow_ahead ?? true,
            settings: (freshSession.settings as Record<string, unknown>) || {},
            ended_at: freshSession.ended_at,
          } : null);
        }
      }
    }, 5000); // More frequent heartbeat for better sync

    return () => {
      console.log('[StudentSession] Cleaning up subscription');
      supabase.removeChannel(channel);
      clearInterval(heartbeat);
    };
  }, [session?.id, participant?.id]);

  // Clear latest prompt after viewing
  const dismissPrompt = useCallback(() => {
    setLatestPrompt(null);
  }, []);

  return {
    session,
    participant,
    prompts,
    latestPrompt,
    responses,
    isJoining,
    joinSession,
    leaveSession,
    submitResponse,
    updateSection,
    dismissPrompt,
  };
}
